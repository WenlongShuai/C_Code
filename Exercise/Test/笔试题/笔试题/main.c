//  笔试题
//


//1、数组和指针笔试题
//数组名大部分为首元素地址，但有两种特别情况
//1、sizeof(数组名)：表示整个数组的大小，单位为字节
//2、&a：表示整个数组的地址
#include <stdio.h>
int main(int argc, const char * argv[])
{
//    int a[] = {1,2,3,4};
//
//    //因为sizeof(a)表示整个数组的大小，数组有4个元素，每个元素的大小为4字节，所以整个数组大小为16个字节
//    printf("%d\n",sizeof(a));   //16
//
//    //虽然 a+0 地址没有改变，但是对数组名进行运算了，就表示a是首元素地址，然后 a+0 也表示首元素地址，所以指针的大小为4/8
//    printf("%d\n",sizeof(a+0));  //4/8   32位机器上为4，64位机器为8
//
//    //*a 对首元素地址进行解引用操作，就表示数组中的1元素，sizeof(1)的大小为4
//    printf("%d\n",sizeof(*a));  //4
//
//    //a+1  表示首元素的地址+1，就是数组的第二个元素的地址，地址的大小为4/8
//    printf("%d\n",sizeof(a+1)); //4/8
//
//    //a[1]  表示数组第一个元素2，sizeof(2)的大小为4
//    printf("%d\n",sizeof(a[1]));  //4
//
//    //&a 表示整个数组的地址
//    //虽然是整个数组的地址，但是还是一个地址，字节大小还是4/8
//    printf("%d\n",sizeof(&a));  //4/8
//
//    //&a  首先取出整个数组的地址，
//    //* &a 然后对其解引用，表示整个数组，大小就为数组的字节大小
//    printf("%d\n",sizeof(*&a)); //16
//
//    //&a  取出整个数组的地址
//    //&a+1 从数组开始的地址跳过一个数组大小的地址，所以大小还是一个地址的大小
//    printf("%d\n",sizeof(&a+1));  //4/8
//
//    //a[0] 表示第0个元素1
//    //&a[0] 表示取出第0个元素的地址，大小还是地址的大小
//    printf("%d\n",sizeof(&a[0]));  //4/8
//
//    //&a[0] 表示取出第0个元素的地址
//    //&a[0]+1  表示在第0个元素的地址基础上+1，得到第1个元素的地址，大小还是地址的大小
//    printf("%d\n",sizeof(&a[0]+1));  //4/8
    
    
    char arr[] = {'a','b','c','d','e'};
    
    //sizeof(arr) 整个数组的大小，5*1 = 5
    printf("%d\n",sizeof(arr));  //5
    
    //arr+0 是首元素地址
    printf("%d\n",sizeof(arr+0));  //4/8
    
    //*arr 表示第一个元素 sizeof('a')为1
    printf("%d\n",sizeof(*arr));  //1
    
    //arr[1] == ‘b’  sizeof('b')为1
    printf("%d\n",sizeof(arr[1])); //1
    
    //&arr  表示整个数组的地址
    printf("%d\n",sizeof(&arr));  //4/8
    
    //&arr+1  从数组的开始位置跳过一个数组大小的位置，实际还是个地址
    printf("%d\n",sizeof(&arr+1));  //4/8
    
    //&arr[0]+1。表示取出第0个元素的地址，然后在第0个元素的地址上+1，跳到第一个元素的地址上
    printf("%d\n",sizeof(&arr[0]+1));  //4/8

    return 0;
}

